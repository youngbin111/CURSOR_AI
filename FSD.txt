## 백엔드 💻

---

### **역할 1: 실시간 시스템 모니터링**

**개념**: 이 기능은 노트북의 현재 상태를 **실시간으로 생중계**하는 채널을 만드는 것입니다.
**Cursor에게 맡길 역할**: "Node.js와 Socket.IO를 사용해서 '실시간 중계 서버'를 만들어줘. 이 서버는 웹사이트와 끊기지 않는 연결을 유지하고, 노트북 상태를 초 단위로 업데이트해줄 거야."

**구현 방식**:

- **통신 방식**: WebSocket을 사용합니다. 일반적인 웹사이트가 페이지를 열고 닫을 때마다 정보를 주고받는 것과 달리, 이 방식은 한 번 연결되면 **계속해서 데이터를 주고받을 수 있는** 전용 회선을 개통하는 것과 같습니다.
- **데이터 흐름**:
    1. 웹사이트가 접속하면, 서버와 전용 회선을 엽니다.
    2. 서버는 노트북에 설치된 '관측병(로컬 에이전트)'에게 "지금 상태를 보고하라"고 명령합니다.
    3. 관측병은 노트북의 CPU, 메모리, 하드 디스크 사용량을 초마다 측정하고, 그 정보를 JSON이라는 형식의 보고서로 서버에 보냅니다.
    4. 서버는 보고서를 받자마자, 전용 회선을 통해 연결된 모든 웹사이트에 그 정보를 뿌려줍니다.
- **중요 데이터**: 이 과정에서 서버가 처리해야 할 데이터는 다음과 같습니다.
    - **CPU**: 현재 사용률 (%)
    - **RAM**: 전체 용량, 사용 중인 용량 (GB)
    - **스토리지**: 전체 용량, 사용 중인 용량 (GB)

---

### **역할 2: 찌꺼기 파일 클리너**

**개념**: 이 기능은 웹사이트의 요청을 받아 노트북의 **'쓰레기통 청소'를 지시하고, 결과를 보고받는** 일련의 과정입니다.

**Cursor에게 맡길 역할**: "Express.js를 사용해서 두 개의 '명령 전달소'를 만들어줘. 하나는 '스캔 명령', 다른 하나는 '삭제 명령'을 처리할 거야. 백엔드는 명령을 전달하고 결과를 기다리는 역할만 하면 돼."
**구현 방식**:

- **통신 방식**: REST API를 사용합니다. 이는 정해진 주소(`URL`)로 명령을 보내고, 그에 대한 응답을 받는 방식입니다.
- **데이터 흐름**:
    - **스캔 요청**:
        1. 웹사이트가 백엔드 서버에 "쓰레기를 스캔해 달라"는 요청을 보냅니다.
        2. 서버는 이 요청을 받으면, '관측병'에게 "지정된 폴더들을 스캔하고, 쓰레기 목록을 보내라"고 명령합니다.
        3. 관측병은 결과를 서버에 보고하고, 서버는 그 목록을 웹사이트에 전달합니다. 이때 목록에는 각 파일의 **이름, 종류(캐시, 임시파일 등), 예상 용량** 정보가 포함됩니다.
    - **삭제 요청**:
        1. 웹사이트가 백엔드 서버에 "이 목록에 있는 파일을 지워달라"는 요청과 함께 삭제할 파일들의 경로(주소)를 보냅니다.
        2. 서버는 받은 경로 목록을 그대로 '관측병'에게 전달하며 "지정된 파일을 삭제하라"고 명령합니다.
        3. 관측병이 삭제를 완료하면, 서버에 **"총 몇 개를 지웠고, 얼마나 많은 용량을 확보했는지"** 보고합니다.
        4. 서버는 이 최종 결과를 웹사이트에 전달하여 사용자에게 보여줍니다.

이 명세는 Cursor AI가 전체적인 백엔드 시스템을 이해하고, 각 기능별로 필요한 코드 구조와 로직을 정확히 파악하는 데 큰 도움이 될 겁니다. 💻

---

---

## 프론트엔드 📈

---

### 역할 1: 실시간 시스템 모니터링 대시보드

**개념**: 사용자가 웹사이트에 접속했을 때 가장 먼저 보게 될 '메인 화면'입니다. 실시간으로 업데이트되는 노트북의 상태를 직관적인 그래프로 보여주는 역할을 합니다.

**Cursor에게 맡길 역할**: "React 컴포넌트로 된 대시보드 페이지를 만들어줘. 이 페이지는 WebSocket을 통해 백엔드로부터 실시간으로 데이터를 받아서 그래프를 업데이트할 거야."

**구현 방식**:

- **컴포넌트 구조**:
    - **메인 대시보드 컴포넌트**: `<DashboardPage>`
    - **하위 컴포넌트**: 각각의 상태를 나타내는 `<CPUGraph>`, `<RAMGraph>`, `<StorageGraph>` 컴포넌트들을 포함해야 합니다.
- **데이터 흐름**:
    1. 사용자가 웹사이트에 접속하면, **백엔드 서버에 WebSocket 연결**을 시도합니다.
    2. `socket.on('system-data', ...)` 리스너를 통해 백엔드에서 보내주는 **`system-data`*라는 이름의 실시간 데이터를 받습니다.
    3. 데이터를 받으면, `useState`를 사용하여 상태를 업데이트하고, 이 상태 값을 기반으로 각 그래프 컴포넌트를 다시 렌더링합니다.
- **화면 요소**:
    - **CPU 그래프**: 원형 또는 바 차트 형태로 CPU 사용률을 보여줍니다. 차트 중앙에 현재 사용량(예: **35%**)을 크게 표시합니다.
    - **RAM 그래프**: 바 차트 형태로 사용 중인 메모리와 전체 메모리 용량(예: **8GB / 16GB**)을 함께 보여줍니다.
    - **스토리지 그래프**: 원형 차트 형태로 사용 중인 용량과 남은 용량을 시각적으로 보여줍니다. 차트 아래에 총 용량(예: **512GB**)을 표기합니다.

---

### 역할 2: 찌꺼기 파일 클리너

**개념**: 사용자가 불필요한 파일을 스캔하고, 목록을 확인한 후, 직접 파일을 삭제할 수 있도록 안내하는 '청소 도구 페이지'입니다.

**Cursor에게 맡길 역할**: "사용자가 찌꺼기 파일을 스캔하고, 결과를 보고, 삭제 방법을 안내받을 수 있는 페이지를 만들어줘. 이 페이지는 백엔드의 REST API를 사용해 데이터를 주고받을 거야."

**구현 방식**:

- **컴포넌트 구조**:
    - **클리너 페이지 컴포넌트**: `<CleanerPage>`
    - **하위 컴포넌트**:
        - `<ScanButton>`: 스캔 시작 버튼
        - `<FileList>`: 스캔 결과 목록을 보여주는 컴포넌트
        - `<DeleteGuide>`: 삭제 방법을 안내하는 모달 또는 페이지 컴포넌트
- **데이터 흐름**:
    1. 사용자가 **'스캔 시작' 버튼**을 클릭하면, `fetch()`를 사용해 백엔드의 `/api/scan-junk` API를 호출합니다.
    2. API 호출이 완료되면, 백엔드로부터 받은 `scanned_files` 데이터를 `useState`에 저장합니다.
    3. 데이터가 저장되면 `<FileList>` 컴포넌트가 렌더링되며, 스캔된 파일 목록을 보여줍니다.
    4. 각 파일 목록 아이템(예: '브라우저 캐시') 옆에는 **확보 가능한 용량**을 표시합니다.
    5. 사용자가 항목을 클릭하면, `useEffect`를 활용하여 **삭제 방법이 담긴 팝업이나 모달**을 띄웁니다. 이 모달에는 백엔드에서 받은 파일 경로를 포함한 명확한 삭제 가이드(예: "파일 탐색기를 열고 **[경로]**로 이동하세요.")가 표시되어야 합니다.
- **화면 요소**:
    - **스캔 버튼**: '내 PC 스캔하기'라는 문구가 포함된 크고 눈에 띄는 버튼.
    - **결과 목록**: 스캔이 끝난 후 나타나는 목록. 각 행은 파일 종류, 확보 가능 용량을 보여주며, 클릭하면 삭제 가이드 팝업이 나타납니다.
    - **삭제 가이드 모달**: 사용자가 특정 항목을 클릭했을 때 뜨는 팝업. 상세한 단계별 설명과 함께 삭제할 파일의 경로를 복사할 수 있는 버튼이 있으면 좋습니다.

이 FSD는 Cursor AI가 전체적인 웹사이트의 화면 구조와 사용자 상호작용 로직을 이해하고, 각 기능별로 필요한 코드 구조를 정확히 파악하는 데 큰 도움이 될 겁니다. 💻

---

### **2. 기능 명세 1: 실시간 시스템 모니터링 대시보드**

**이 기능은 무엇인가요?**

- 여러분의 노트북이 지금 얼마나 바쁘게 일하고 있는지 보여주는 **'건강 검진 결과표'**라고 생각하시면 됩니다. 웹사이트에 접속하면 CPU, RAM, 스토리지의 사용량이 실시간으로 나타납니다.

**어떻게 작동하나요?**

1. **병원 방문**: 여러분이 CleanBoost 웹사이트에 접속합니다.
2. **검진 요청**: 웹사이트는 여러분의 노트북에 설치된 'CleanBoost 검진 도우미(에이전트)'에게 "지금 상태를 알려줘"라고 요청합니다.
3. **결과 보고**: 검진 도우미는 노트북의 상태를 확인하고, 그 결과를 웹사이트로 **초당 수십 번씩** 빠르게 보냅니다.
4. **결과표 전시**: 웹사이트는 받은 데이터를 멋진 **그래프와 숫자로 변환**하여 여러분의 화면에 보여줍니다. 이 과정이 계속 반복되어 마치 시계처럼 실시간으로 변동하는 모습을 볼 수 있습니다.

**구현될 화면 요소**:

- **CPU 사용량**: 현재 컴퓨터의 '두뇌'가 얼마나 바쁘게 일하고 있는지 원형 그래프로 보여줍니다. 퍼센트(%)와 함께 '사용 중인 양'을 같이 표시합니다.
- **RAM 사용량**: 컴퓨터의 '단기 기억력'인 RAM이 얼마나 사용되고 있는지 보여줍니다. 남은 여유 공간을 명확히 보여줘서, "아, 창을 너무 많이 띄웠구나"하고 바로 알 수 있게 해줍니다.
- **스토리지(하드 디스크) 용량**: 노트북의 '서랍장'인 하드 디스크에 얼마나 많은 파일이 차 있는지 보여줍니다. 총 용량과 사용 중인 용량을 비교해 얼마나 더 많은 파일을 저장할 수 있는지 쉽게 알 수 있습니다.

---

### **3. 기능 명세 2: 찌꺼기 파일 클리너**

**이 기능은 무엇인가요?**

- 노트북에 쌓여 있는 불필요한 쓰레기(임시 파일, 캐시 등)를 찾아내서 여러분이 쉽게 버릴 수 있게 도와주는 '자동 청소기'입니다.

**어떻게 작동하나요?**

1. **청소 시작**: 사용자가 웹사이트에서 "청소 시작" 버튼을 누릅니다.
2. **쓰레기통 탐색**: 웹사이트가 'CleanBoost 검진 도우미'에게 "쓰레기통을 찾아줘"라고 명령합니다.
3. **목록 보고**: 검진 도우미는 노트북의 정해진 쓰레기통들(인터넷 캐시 폴더, 임시 파일 폴더, 휴지통)을 꼼꼼하게 탐색하고, 찾은 쓰레기들을 종류별로 분류하여 웹사이트에 보고합니다.
4. **선별 및 삭제**: 웹사이트는 보고받은 쓰레기 목록을 보여주며, 여러분이 필요한 것만 남기고 지울 것을 선택할 수 있게 합니다.
5. **버리기**: 여러분이 "선택 삭제" 버튼을 누르면, 검진 도우미가 해당 쓰레기들을 깨끗하게 치워줍니다.

**구현될 화면 요소**:

- **스캔 버튼**: "내 PC 스캔하기" 버튼이 화면 중앙에 배치됩니다.
- **스캔 결과 목록**: 스캔이 끝나면 아래와 같은 목록이 나타납니다.
    - **항목명**: '인터넷 캐시', '휴지통', '임시 파일' 등
    - **발견된 파일 수**: 각 항목별로 찾은 파일의 개수
    - **확보 가능 용량**: 해당 항목을 삭제하면 얼마나 많은 용량을 확보할 수 있는지
    - **체크박스**: 각 항목을 선택하거나 해제할 수 있는 체크박스
- **~~최종 삭제 버튼**: "선택된 파일 삭제" 버튼을 누르면, 애니메이션과 함께 삭제 진행 상태를 보여주고, 완료 후에는 "총 확보 용량: 5.4 GB"와 같은 최종 결과를 알려줍니다.~~

**참고 사항**:

- **보안 문제**: 웹사이트가 여러분의 개인 파일(사진, 문서 등)에 함부로 접근할 수 없습니다. 이는 보안 규칙상 허용되지 않기 때문입니다. 그래서 이 기능을 사용하려면 웹사이트와 통신할 수 있는 작은 **'보조 프로그램'**을 따로 설치해야 합니다. 이 프로그램이 여러분의 노트북에서 안전하게 쓰레기만 찾고 삭제하는 역할을 합니다.

이러한 FSD는 프로젝트의 방향을 명확하게 하고, 각 기능이 어떻게 보이고 작동할지 모두가 쉽게 이해할 수 있게 도와줍니다. 📖

---

---

### API 설계

---

백엔드 서버는 프론트엔드와 로컬 에이전트 간의 통신을 담당하는 중추적인 역할을 합니다. API는 **RESTful API**와 **WebSocket**으로 구성됩니다.

- **1.1. 실시간 시스템 모니터링 (WebSocket)**
    - **목표**: 로컬 에이전트로부터 실시간 데이터를 받아 프론트엔드로 전달합니다.
    - **메시지 형식 (에이전트 → 서버)**: 에이전트는 1초마다 다음 형식의 JSON 데이터를 WebSocket을 통해 서버로 전송합니다.
    
    JSON
    
    ```jsx
    {
      "cpu_usage_percent": 35.5,
      "ram_total_gb": 16,
      "ram_used_gb": 8.2,
      "storage_total_gb": 512,
      "storage_used_gb": 250
    }
    ```
    
    - **메시지 형식 (서버 → 프론트엔드)**: 서버는 받은 데이터를 `system_data`라는 이벤트명으로 프론트엔드에 브로드캐스트합니다.
    
    JSON
    
    ```jsx
    {
      "cpu_usage_percent": 35.5,
      "ram_total_gb": 16,
      "ram_used_gb": 8.2,
      "storage_total_gb": 512,
      "storage_used_gb": 250
    }
    ```
    
- **1.2. 찌꺼기 파일 클리너 (REST API)**
    - **목표**: 프론트엔드의 요청에 따라 로컬 에이전트에게 파일 스캔 및 삭제 명령을 내립니다.
    - **`POST /api/scan`**: 파일 스캔 요청
        - **요청 바디**: `{}` (빈 객체)
        - **응답 바디**: 스캔이 완료되면 파일 목록을 반환합니다.JSON
            
            `{
              "status": "success",
              "files": [
                {
                  "name": "Chrome 캐시",
                  "category": "browser_cache",
                  "size_mb": 250.5,
                  "path": "/Users/user/Library/Caches/Google/Chrome"
                },
                {
                  "name": "시스템 임시 파일",
                  "category": "system_temp",
                  "size_mb": 120.3,
                  "path": "/Users/user/temp"
                }
              ]
            }`
            
    - **`POST /api/delete`**: 파일 삭제 요청
        - **요청 바디**: 삭제할 파일 경로 목록을 받습니다.JSON
            
            `{
              "paths": [
                "/Users/user/Library/Caches/Google/Chrome",
                "/Users/user/temp"
              ]
            }`
            
        - **응답 바디**: 삭제 완료 후 결과를 반환합니다.JSON
            
            `{
              "status": "success",
              "deleted_count": 2,
              "total_freed_space_mb": 370.8
            }`